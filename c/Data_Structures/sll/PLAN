* SLL Node functions:
	[X] Create node
	[X] Delete node
	[X] Print node

* SLL functions:
	[ ] Allocator and Deallocator functions
		[ ] set_allocator(allocatefn)
			- Will be used for all allocations within the SLL,
			- in the absence of an allocatorfn, malloc()/own memory manager's allocate will be used
		[ ] set_deallocator(deallocatefn)
			- Will be used for all de-allocations within the SLL,
			- in the absence of an deallocatorfn, free()/own memory manager's deallocate will be used
	[-] Insert:
		[X] AtFirst (data, node)
		[X] AtEnd (data, node)
		[X] AtPos (data, node)
		[X] Atpos from end (data, node)
		[X] After (data, node) # Insert after matching data/node
		Before (data, node) # Insert before matching data/node
	Remove:
		[X] AtFirst (data, node)
		[X] AtEnd (data, node)
		[X] AtPos (data, node)
		Atpos from end (data, node)
		data, node # find and remove matching node/data
		After (data, node) 
		Before (data, node)
		Remove specified node # swap next.. works only if not last node
	Find:
		[X] Find (node, data): return node containing key/data matching key
		Findpos (node, data): return position matching node containing key/key
		Find node(node): Check if node exists in SLL
		nth Element from the front
		nth Element from the end
		Smallest element in the SLL
		Largest element in the SLL
		kth order statistics 
			kth smallest element in the SLL
			kth largest element in the SLL
		find element next smaller than key in the SLL
		find element next larger than key in the SLL
	Print:
		[X] PrintSLL
		PrintSLL reverse
		printSLL recursive
		printSLL reverse recursive
	Sort:
		Place(data)
		Sort SLL
	Export:
		(To containers)
		To xor LL (inplace)
	Import:
		(From containers)
	splice:
		pos1-pos2
	Set Operations:
		Join
		Union
		Intersection
		Find point of intersection
	Loop:
		find if loop exists
		find node at which sll loops
	Reverse:
		reverse
		reverse recursive
	[X] Destroy:
		[X] Delete SLL internal state (nodes, data, etc)
		[X] Destroy SLL completely
	
